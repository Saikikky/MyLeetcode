/*对s=5开方，保留n位小数 
算法大致思路：
   e=(sqrt(5)-1)/2; 关键是求出5的平方根，小数点后n(=101)位 
   用char e[1~n]表示sqrt(5)的小数点后n位，e[0]为整数位，
   分别穷举e[1]=0~9的情况，
   如果e[1]=k时，表达式e*e的结果e1[0~2n]中，e[0]>5，则e[1]还原为k-1,e1[]也还原回去 
   然后依此方式继续枚举e[2]的情况
   程序中的关键处
       sqrt(5)为e[]：e[0].e[1]e[2]....e[i]           【1<=i<=n】 
          e[]*e[]为：e1[0].e1[1]e1[2]..e1[i]..e1[2*i] 【1<=i<=n】 
         显然e[]比理论上的sqrt(5)位数少,所以必须满足e1[0]<5 
    枚举e[i]时【从0~9范围变化】，不看小数点，e[0~i]为大整数，e[i]每增大1，
	e[]*e[]的表达式相当于
	 (e[0]e[1]e[2]....e[i]+1)*(e[1]e[2]....e[i]+1)
	=(e[1]e[2]....e[i])^2 + 2*(e[1]e[2]....e[i]) +1
    【变化前结果e1[0~2i]】 【e1[i~2i]的增量】 【e1[2i]的增量】 
    
	所以只需将 增量部分 加进来即可。
	计算完之后，如果发现e1[0]>=5，则说明e[i]大了1个，
	将e1[]还原，继续枚举e[i+1]。 
*/
#include<stdio.h>
#include<math.h> 
#define M 10002 
char e[M],e1[M*2],e2[M*2];

int main()
{
	int i,j,add,t,s=5,n=101; //可以置n为10001，求出sqrt(s)的10001位小数，用时5秒左右。 
	printf("\n输入被开方数s和保留小数位数n:");
	scanf("%d%d",&s,&n);
	e[0]=sqrt(s);//整数位就不用枚举了
	e1[0]=e[0]*e[0]; 
	for(i=1;i<=n;i++)//求小数点后第i位：e[i] 
	{
		do
		{
			for(j=2*i;j>=0;j--) 
			{ 
			    e2[j]=e1[j];
			}
			e1[2*i]++;//前面解释的【e1[2i]的增量】
			add=0;
			for(j=2*i;j>=i;j--)//【e1[i~2i]的增量】  
			{
				t=add+e1[j]+2*e[j-i];
				e1[j]=t%10;
				add  =t/10; 
			}
			while(j>0 && add)//处理进位
			{//e1[0]不再继续往前进位，所以j>0 
				t=e1[j]+add;
				e1[j]=t%10;
				add  =t/10;
				j--;
			}
			e1[j]=e1[j]+add;//不管j是否为0，最后一个进位add加入e1[j] 
						
			if(e1[0]>=s)
			{
				for(j=2*i;j>=0;j--) 
			    { 
				    e1[j]=e2[j];//恢复前一次的e[]*e[]
			    }
				break;
			}
			e[i]++;//如果if(s1[1]>9)不成立，则没有break，则将e[i]值增加1 
		}while(1);
	}//end for 
	printf("\nsqrt(%d)=%d.",s,e[0]);
	for(i=1;i<=n;i++) printf("%d",e[i]); 
}

/*1.取数博弈游戏 
今盒子里有n个小球，A、B两人轮流从盒中取球，每个人都可以看到另一个人取了多少个，也可以看到盒中还剩下多少个，并且两人都很聪明，不会做出错误的判断。
我们约定：    
    每个人从盒子中取出的球的数目必须是：1，3，7或者8个。
    轮到某一方取球时不能弃权！
    A先取球，然后双方交替取球，直到取完。
    被迫拿到最后一个球的一方为负方（输方）

    请编程确定出在双方都不判断失误的情况下，对于特定的初始球数，A是否能赢？

    程序运行时，从标准输入获得数据，其格式如下：
    先是一个整数k(k<100)，表示接下来有k个整数。然后是k个整数，每个占一行（整数<10000），表示初始球数。
    程序则输出k行，表示A的输赢情况（输为0，赢为1）。
    例如，用户输入：
4
1
2
10
18
则程序应该输出：
0
1
1
0

解：用f(n)表示首先面对n个球的人，是否能赢，能赢则函数值为1，否则为0，则有
	  
		  1                                                n=0
          0                                                n=1
          1                                                n=2
		  0                                                n=3
f(n)={	  1                                                n=4
		  0                                                n=5
		  1                                                n=6
		  0                                                n=7
		  1                                                n=8
          !f(n-1) || !f(n-3) || !f(n-7) || !f(n-8)         n>8

  或者简化为：	  
		  1                                                n<=0
  f(n)={  0                                                n=1 
          !f(n-1) || !f(n-3) || !f(n-7) || !f(n-8)         n>1

  
*/

#include<iostream>
using namespace std;

int a[100];//a[i]与f(i)对应，1表示赢，0表示输，程序中用-1表示未计算过（即保持着初始化的值）
int f(int n)
{
	if(n<=0)    return 1; //此处不要将1保存到a[i]中，因为i可能小于0，而且需将此语句放在if(a[n]!=-1) return a[n]的前面
	if(a[n]!=-1)return a[n];//已经计算过，直接返回
    
	if(n==1)    return a[n]=0;
	else        return a[n]=  (!f(n-1)) || (!f(n-3)) || (!f(n-7)) || (!f(n-8));
}

int main()
{
	int k,n;
	for(k=0;k<100;k++) a[k]=-1;//初始化为未计算的标志
	cin>>k;
	while(k)
	{
		cin>>n;
		cout<<f(n)<<endl; 
		k--;
	}
	return 0;
}
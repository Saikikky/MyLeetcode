//测试一般函数和递归函数的内存有关问题
/*大致结论：（主要是vc环境下的测试结果，devc下依此类推）
   (1)vc中一般函数内部申请的数组（或栈内存）大小大约接近1MB（devc下接近2MB）。
      如果需申请超出这个值，应该在堆内存上申请(用new,malloc或static,全局数组等方式)。
   (2)与一般函数一样，递归函数也只有1MB的栈内存。
      而且在递归调用的层层深入过程中，所有的栈内存加起来也不能超出这个值，否则被强行结束。
	  例如下面递归函数f(n)在n=804时，依次递归调用f(804),f(803),f(802)...f(2),f(1),f(0),每次进入都
	  执行int a[300];即申请了300*4B=1200B，前后一共申请805*1200B，加上形参n和其它环境参数所占内存，
	  刚好超出这个值，所以f(804)就被强行结束了。不难理解，如果数组a[]越大，会更快超出这个值，
	  导致f(i)调用时，i很小时就被强行结束了。
   (3)如果递归函数内部局部变量越少，其能进行的递归深度会越深，例如g()能递归深入到12334层，
      而f(n)中即使不定义数组也只能到11773层,说明形参n让1MB的栈内存更快的被用完了。
   (4)尽量不要在递归函数中定义过多变量（包括数组），因为它们会导致递归的深度更小。
      当递归的深度达到10000以上时，应该尽量改用循环。

   【注：(2),(3),(4)其实说的是同一个本质问题，尤其注意记住(4)】
*/
#include<iostream>
using namespace std;

int x[1000][1000];//全局变量在堆内存上，不要过度申请内存
int m=0;

void f0()//一般函数
{
	char a[1011][1024], b[676];//申请的内存接近1MB，超出即被强行结束
	//static char b[5000][1000];//static修饰过，在堆内存上，malloc,new可另加语句去测试。
}

void f(int n)//递归函数
{
	int a[300]; //int *a=new int[50];
	if(n>0) f(n-1);
	//delete a;
}

void g()//没有形参的递归函数，通过全局变量m控制其递归退出
{
	m--;
	if(m>0) g();
}

int main( )
{  
	int i;
	f0();

	for(i=1;i<100000;i++)
	{
		cout<<i<<endl;
		f(i);
	}

	for(i=1;i<200000;i++)//如果要测试g()，应该把上面的for循环注释起来
	{
		cout<<i<<endl;
		m=i;
		g();//g()的递归深度由m反映
	}
	return 0;
}